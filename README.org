#+title: zref-check

*Flexible cross-references with contextual checks based on zref*

* Introduction

=zref-check= provides an user interface for making LaTeX cross-references
exploiting document contextual information to enrich the way the reference is
rendered.  In so doing, it caters to the same kind of need as =varioref= does.
But the UI concept is quite different.  I think it is fair to say that, in
relation to =varioref=, =zref-check= offers a little less automation and a lot
more flexibility.

The basic idea is that, instead of trying to provide the text to be typeset
based on the contextual information (as =varioref= does), =zref-check= lets the
user supply an arbitrary text and specify a number of checks to be done on the
label(s) being referred to.  If the checks fail, a warning is issued upon
compilation, so that the user can go back to that cross-reference and correct
it as needed.  In a way, this shares the spirit of =widows-and-orphans=: instead
of trying to fix it for you automatically (as =nowidow= does), it just provides
a warning so that the problem can be identified (and fixed) without having to
rely on burdensome and error prone manual proof-reading.

Though, admittedly, the kind of automation =varioref= provides may be preferred
for a number of use cases, in others there is a lot to gain on the extra
flexibility =zref-check= provides.  The writing style, the variety of
expressions you may use for similar situations, does not need to be sacrificed
for the convenience.  =zref-check= cross-references do not need to “feel”
automated to be consistently checked.  Localization is also not an issue, for
the same reason.  There is also much more document context we can leverage by
separating “typesetting” from “checking” (see [[#checks][Checks]]).

=zref-check= depends on =zref=, as the name entails, which means it is able to
work with =zref= labels, usually created by =\zlabel=.  This provides some
advantages, particularly the data flexibility of =zref=, and the absence of the
ubiquitous “load-order” and compatibility problems which are well known to
afflict LaTeX packages of this area of functionality.  On the other hand, the
reliance on =\zlabel= may be seen as an inconvenience, since users of the
standard cross-reference infrastructure will need to add extra labels for
this.  That’s true.  But =zref-check= is not meant to replace the existing
functionality of the traditional packages (to my knowledge, it only intersects
directly with =varioref=).  It is easy to see the use in conjunction with
standard references, for example:

#+begin_src latex
... see Figure~\ref{fig:figure-1}, \zrcheck*{fig:figure-1}[nextpage]{on the next page}.
#+end_src

Besides, =zref= does not share the label name-space with the standard labels, so
that you can call both =\label= and =\zlabel= with the same label name (manually,
or through a convenience macro), to ease the label set administration.  The
example above presumes that was the case.


** Hard vs. soft cross-references

The standard LaTeX cross-reference infrastructure, even considering the
package ecosystem, is made to work with and refer to specific numbered
document elements.  Chapters, sections, figures, tables, equations, etc.  The
cross-reference will normally produce that number (which is the element’s
“id”) and, eventually, its “type” (the counter).  We may also refer to the
page that element occurs and even its “title” (in which case, atypically, we
may even get to refer to an unnumbered section, provided we also implicitly
supply by some means the “id”).  These are what I’m calling here “hard”
cross-references.

However, there are other kinds of “soft” cross-references we routinely do in
our documents.  Expressions such as “as previously discussed”, “as mentioned
before”, “as will be soon elaborated” and on, and on, are a powerful
discursive instrument, which enriches the text, by offering hints to the
arguments’ threads, without necessarily “smashing them into the reader’s
face”.  So, we don’t say “on footnote 57, pag. 34”, but “previously”, not “on
Section 3.4”, but “below”, or “later on”.

Granted, the need and usage of this type of document self reference certainly
depend on the kind of document, on the area of knowledge, etc.  However, they
do tend to be employed in a number of places, particularly in longer
documents.  And that’s precisely the scenario in which they may become
problematic.  If your document is short (say, a paper / article) and it was
made in a reasonably short spurt, you’ll probably won’t bother with this kind
of references.  In this case, and to use =varioref= ’s expression, you “usually
know (!)” them to be correct.  However, if you are preparing one of those
long, complex, and “long ground” documents, with several rounds of editing and
content rearranging, this kind of references will likely bring you trouble.
They are not only hard to check and find, but they are also hard to fix.
After all, if you are making one such reference, you are taking that statement
as a premisse at the current point in the text.  So, if that reference is
missing, or relocated, you may need to bring in the support to the premisse
for your argument to close, rather than just “adjust the reference text”.

To my knowledge, there is no LaTeX package providing support for this kind of
cross-reference, =zref-check= does so.  Of course, this is already possible with
the standard infrastructure, =zref-check= just streamlines the task.


* Loading the package

As usual:

#+begin_src latex
\usepackage[<options>]{zref-check}
#+end_src

Options are a standard key=value comma separated list, and can also be set by
means of =\zrchecksetup=.  The above would be equivalent to:

#+begin_src latex
\usepackage{zref-check}
\zrchecksetup{<options>}
#+end_src


* Dependencies

=zref= is required, of course, but in particular, its modules =zref-user= and
=zref-abspage= are loaded by default.  =ifdraft= is also required by default.  A
recent LaTeX kernel is presumed (but not checked), since we rely on the new
hook system from =ltcmdhooks= for the sectioning checks.  If =hyperref= is loaded
and option =hyperref= is given, =zref-check= makes use of it, but it does not load
the package for you.


* User interface

- =\zrcheck[<options>]{<labels>}[<checks>]{<text>}=
  + Typesets =<text>=, as given, while performing the comma separated list of
    =<checks>= on each of the comma separated list of =<labels>=.  In addition to
    that, it places a pair of (internal) =zlabel= s, one at the start of =<text>=,
    another one at the end of =<text>=, which are used to run the checks against
    each of the =<labels>=.  When =hyperref= support is enabled, =<text>= will be
    made a hyperlink to /the first/ label in =<labels>=.  The starred version of
    the command does the same, just does not form a link.  The =<options>= are
    (mostly) the same as those of the package, and can be given to local
    effect.  Note that the =<text>= argument of =\zrcheck= is not long (that of
    =\zrctarget= is) because, if it was, we’d not be able to use if for building
    hyperlinks, besides there is no need for it to be.
- =\zrctarget{<label>}{<text>}=
  + Typesets =<text>=, as given, and places a pair of =zlabel= s, one at the start
    of =<text>=, using =<label>= as label name, another one (internal) at the end
    of =<text>=.
- =\begin{zrcregion}{<label>} <text> \end{zrcregion}=
  + Just an environment that does pretty much the same as =\zrctarget=, for
    cases of longer stretches of text.  If you don’t like to use the
    environment for whatever reason, you may also set two =\zrctarget= s (with
    empty =<text>= arguments), one at the beginning and another one at the end,
    and run =\zrcheck= against both of them to the same effect.


* Checks

- =thispage=, =prevpage=, =nextpage=, =facing=
  + self-explanatory.
- =above=, =below=
  + label referred to occurs in this page and, respectively, “above” or
    “below” the reference.  For how this is inferred, see [[#within-page-checks][Within page checks]].
- =pagesbefore=, =pagesafter= (with convenience aliases =ppbefore=, =ppafter=)
  + self-explanatory.
- =before=, =after=
  + “before” is either =above= or =pagesbefore=; “after” is either =below= or
    =pagesafter=.
- =thischap=, =prevchap=, =nextchap=, =chapsbefore=, =chapsafter=, =thissec=, =prevsec=,
  =nextsec=, =secsbefore=, =secsafter=
  + self-explanatory.
- =close=, =far=
  + “close” means occurring from =closerange= pages before the reference to
    =closerange= pages after the reference (see corresponding option, the
    default value is 5).  “far” is “not close”.

The checks may be combined, e.g. =[close, after]=, or =[thischap, before]=.
Whether the combination is meaningful, is up to the user.  As is the
correspondence between the =[<checks>]= and the ={<text>}= in =\zrcheck=.


* Options

- =hyperref=: takes values =auto=, =true=, =false=
  + The default value, =auto=, makes =zref-check= use =hyperref= if it is loaded,
    meaning =\zrcheck= can be hyperlinked to the first label in =<labels>=.  =true=
    does the same thing, but warns if =hyperref= is not loaded (=hyperref= is
    never loaded for you).  In either case, if =hyperref= is loaded, module
    =zref-hyperref= is also loaded by =zref-check=.  =false= means not to use
    =hyperref= regardless of its availability.  This is a preamble only option,
    but =\zrcheck= provides granular control of hyperlinking by means of its
    starred version.
- =msglevel=: takes values =warn=, =info=, =none=, =obeydraft=, =obeyfinal=
  + Sets the level of messages issued by =\zrcheck= failed checks.  The default
    is =warn=.  =warn= issues messages both in the terminal and log file, =info=
    issues messages in the log file only, =none= suppresses all messages.
    =obeydraft= corresponds to =info= if option =draft= is passed to =documentclass=,
    and to =warn= otherwise.  =obeyfinal= corresponds to =warn= if option =final= is
    (explicitly) passed to =documentclass= and =info= otherwise.  =ignore= is
    provided as convenience alias for =msglevel=none= for local use only.  This
    option only affects the messages issued by the checks in =\zrcheck=, not
    other checks of the package.  In particular, it does not affect warnings
    issued for undefined labels, which just use =\zrefused= and thus are the
    same as standard LaTeX ones for this purpose.
- =onpage=: takes values =labelseq=, =msg=, =obeydraft=, =obeyfinal=
  + Allow to control the messaging level for “within page checks”.  The
    default, =labelseq= uses the labels’ shipout sequence, as retrieved from the
    .aux file, to infer relative position within the page.  =msg= also uses the
    same method for checking relative position, but issues a (different)
    message *even if the check passes*, to provide a simple workflow for robust
    checking of “false negatives” at a final typesetting stage of the
    document, considering the label sequence is not fool proof (for details,
    see [[#within-page-checks][Within page checks]]).  =msg= issues its messages as defined by =msglevel=.
    =obeydraft= corresponds to =labelseq= if option =draft= is passed to
    =documentclass= and to =msg= otherwise.  =obeyfinal= corresponds to =msg= if
    option =final= is (explicitly) passed to =documentclass=, and to =labelseq=
    otherwise.
- =closerange=: takes an integer as value
  + Defines the width of range of pages relative to the reference, that are
    considered “close” by the =close= check.  Default is 5.


* Label names

All user commands have their =<label>= arguments protected by =zref= ’s
=\zref@wrapper@babel= so that we should have equivalent support in that regard,
as =zref= itself does.  However, =zref-check= sets labels which either start with
=zrefcheck@= or end with =@zrefcheck=, for internal use.  Label names with either
of those are considered reserved by the package.


* Technique and limitations

There are three qualitatively different kinds of checks being used by
=\zrcheck=, according to the source and reliability of the information they
mobilize: page number checks, within page checks, and sectioning checks.


** Page number checks

Page number checks -- =thispage=, =prevpage=, =nextpage=, =facing=, =pagesbefore=,
=pagesafter= -- use the =abspage= property provided by the =zref-abspage= module.
This is a solid piece of information, on which we can rely upon.  However,
despite that, page number checks may still become ill-defined, if the =<text>=
argument in =\zrcheck=, when typeset, crosses page boundaries, and starts in one
page, and finishes in another.  The same with the text in =\zrctarget= and the
=zrcregion= environment.

This is why the user commands of this package set always a pair or labels
around =<text>=.  So, when checking =\zrcheck= against a regular =zlabel= both the
start and the end of the =<text>= are checked against the label, and the check
fails if either of them fails.  When checking =\zrcheck= against a =\zrctarget= or
a =zrcregion=, both beginnings and ends are checked against each other two by
two, and if any of them fails, the check fails.  In other words, if a page
number checks passes, we know that the entire =<text>= arguments pass it.

This is a corner case (albeit relevant) which must be taken care of, and it is
possible to do so robustly.  Hence, we can expect fully reliable results in
these tests.


** Within page checks

When both label and reference fall on the same page things become much
trickier.  This is basically the case of the checks =above= and =below= (and,
through them, =before= and =after=).  There is no equally reliable information
(that I know of) as we have for the page number checks for this, especially
when floats come into play.  Which, of course, is the interesting case to
handle.

To infer relative position of label and reference on the same page, =zref-check=
uses the labels’ shipout sequence, which is retrieved at load-time from the
order in which the labels occur in the .aux file.  Indeed, =zref= writes labels
to the .aux file at shipout (and, hence, in shipout order), and needs to do
so, because a number of its properties are only available at that point.

However, even if this method will buy us a correct check for a regular float
on a regular page (which, to be fair, is a good result), it is not difficult
do conceive situations in which this sequence may not be meaningful, or even
correct, for the case.  A number of cases which may do so are: two column
documents, text wrapped around boxes, scaling, overlays, etc.  (I don’t know
if those make the method fail, I just don’t know if they don’t).  Therefore,
the =labelseq= should be taken as a /proxy/ and not fully reliable, meaning that
the user should be watchful of its results.

For this reason, =zref-check= provides an easy way to do so, by allowing
specific control of the messaging of the checks which do within page
comparisons, and thus rely on this method, though the option =onpage=.  The
concern is not really with false positives (we get a warning when it was not
due), but with false negatives (we don’t get a warning when it was due).
Hence, setting =onpage= to =msg= (or to =obeydraft= or =obeyfinal= if that’s part of
your workflow) at a final typesetting stage provides a way to easily identify
all cases of such checks (failing or passing), and double-check them.  In case
the test is passing though, the message is different from that of a failing
check, to quickly convey why you are getting the message.  This option can
also be set at the local level, if the page in question is known to be
problematic, or just atypical.


** Sectioning checks

The information used by sectioning checks is provided by means of dedicated
counters for chapters and sections, similarly as standard counters for them,
but which are stepped and reset regardless of whether these sectioning
commands are numbered or not (that is, starred or not).  And this for two
reasons.  First, we don’t need the absolute counter value to be able to make
the kind of relative statement we want to do here.  Second, this allows us to
have these checks work for numbered and unnumbered sectioning commands without
having to worry about how those are used within the document.

The caveat is that the package does this by hooking into =\chapter= and
=\section=, which poses two restrictions for the proper working of these checks.
First, we are using the new hook system for this, as provided by =ltcmdhooks=,
which means a recent LaTeX kernel is required (this might be circumvented with
=etoolbox=, but I’m not sure how restrictive this issue may be and, if at all
possible, I’d prefer to stick to the new hook system).  Second, since we are
hooking into =\chapter= and =\section=, these checks presume these commands are
being used by the =documentclass= for this purpose (either directly, or
internally as, for example, KOMA-Script’s =\addchap= and =\addsec= do).  If that’s
not the case, additional setup may be required for these checks to work as
expected.
