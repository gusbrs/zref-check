

\ProvidesExplPackage {zrefcheck} {2021-07-06} {alpha}
  {Flexible cross-references with relative position checks based on zref}

\RequirePackage { zref-user }
\RequirePackage { zref-abspage }
\RequirePackage { zref-savepos }

\RequirePackage { zref-abschap }


% We need 'zref's label commands to issue '\zref@savepos' every time, and not
% just when using the 'savepos' module's commands, because we want every
% 'zlabel' to have proper coordinates.  For this reason, we have to run a call
% to '\zref@savepos' on a "before hook" to '\ZREF@label'.  However, since the
% required information (position on the page of the text to which the label
% refers to) is only known at shipout, we do this call under a dummy (writes
% nothing) call to '\protected@write' to execute '\zref@savepos' right before
% '\ZREF@label's job is done, emulating what this command does in this regard.
% I think this is somewhat institutionalized, see David Carlile's comment at
% https://tex.stackexchange.com/a/98810 regarding the '#2' argument of
% '\protected@write'.  See also the discussion in egreg's answer to the same
% question.  Of course, that is also what '\ZREF@label' itself does and,
% ideally, we'd just place '\zref@savepos' inside it.
\hook_gput_code:nnn { cmd / ZREF@label / before } { zrefcheck }
  {
    \if@filesw
      \begingroup
        \protected@write \@auxout {
          \zref@savepos
        }{}
      \endgroup
    \fi
  }


% Add 'posx'/'posy' to the 'main' list properties, so that the labels created
% with the standard '\zlabel' from the 'user' module carries the position
% information.
\zref@addprop \ZREF@mainlist { posx }
\zref@addprop \ZREF@mainlist { posy }


% This is the list of properties to be used by the '\zrefcheck' command.
\zref@newlist { zrefcheck }
\zref@addprops { zrefcheck }
  {
    % minimum set needed
    abspage ,
    abschap ,
    abssec ,
    % if page position is being used
    posx ,
    posy ,
    % for use in warning messages
    page
  }


% Alternate method for determining relative position: the sequence in which
% the labels get shipped out.  Sort of getting the sequence in which the
% labels occur in the .aux file.

% Some relevant info about the sequence of things:
% https://tex.stackexchange.com/a/120978 and 'texdoc lthooks', section "Hooks
% provided by \begin{document}".

\seq_new:N \g__zrefcheck_auxfile_labelseq_seq

% Thanks to Ulrike Fischer: https://tex.stackexchange.com/q/604265
\cs_gset_protected:Npn \zref@newlabel #1#2
  {
    \seq_gput_right:Nn \g__zrefcheck_auxfile_labelseq_seq {#1}
    \@newl@bel {\ZREF@RefPrefix} {#1} {#2}
  }

\prop_new:N \g__zrefcheck_auxfile_labelseq_prop

\cs_new:Npn \__zrefcheck_process_labelseq:
  {
    \prop_gclear:N \g__zrefcheck_auxfile_labelseq_prop
    \group_begin:
      \int_zero:N \l_tmpa_int
      \seq_map_inline:Nn \g__zrefcheck_auxfile_labelseq_seq
        {
          \int_incr:N \l_tmpa_int
          \prop_gput:Nnx \g__zrefcheck_auxfile_labelseq_prop
            { ##1 } { \int_use:N \l_tmpa_int }
        }
    \group_end:
  }

\hook_gput_code:nnn { begindocument } { zrefcheck }
  { \__zrefcheck_process_labelseq: }

\NewDocumentCommand \showalllabels { } {
  \prop_show:N \g__zrefcheck_auxfile_labelseq_prop
}



%% The main user-facing command

\int_new:N \g__zrefcheck_id_int
\tl_new:N \l__zrefcheck_refbeg_tl
\tl_new:N \l__zrefcheck_refend_tl

% *[<options>]{<labels>}[<checks>]{<text>}
\NewDocumentCommand \zrefcheck { s O { } m O { } +m }
  {
    \int_gincr:N \g__zrefcheck_id_int
    \mode_leave_vertical:
    \group_begin:
      \tl_set:Nn \l__zrefcheck_refbeg_tl
        { zrefcheck@ \int_use:N \g__zrefcheck_id_int @beg}
      \tl_set:Nn \l__zrefcheck_refend_tl
        { zrefcheck@ \int_use:N \g__zrefcheck_id_int @end }
      % Set start label
      \zref@labelbylist { \l__zrefcheck_refbeg_tl } { zrefcheck }
      % Typeset "<text>"
      #5
      % Set end label
      \zref@labelbylist { \l__zrefcheck_refend_tl } { zrefcheck }
      % Now we do the checking

      \__zrefcheck_do_check:nnx { thispage } {#3} { \l__zrefcheck_refbeg_tl }

    \group_end:
  }



%% Auxiliary functions


% A convenience function to retrieve property values from labels.  Uses
% '\g__zrefcheck_auxfile_labelseq_prop' for "labelseq", and calls
% '\zref@extract' for everything else.

% We cannot use the return value of '\__zrefcheck_get:' directly, because we
% need to use the retrieved property values as arguments in the checks,
% however we use here a number of non-expandable operations.  Hence, we
% receive a local tl variable ('\l__zrefcheck_prop_value_tl' is provided for
% that) as third argument and set that, so that it is available (and
% expandable) at the place of use.  For this reason, we do not group here,
% because we are passing a local variable around, but it is expected this
% function will be called within a group.
\tl_new:N \l__zrefcheck_prop_value_tl

% {<label>}{<prop>}{<tl var>}
\cs_new:Npn \__zrefcheck_get_astl:nnn #1#2#3
  {
    \tl_clear:N \l_tmpa_tl
    \tl_clear:N #3
    \tl_if_eq:nnTF {#2} { labelseq }
      {
        \prop_get:NnNTF
          \g__zrefcheck_auxfile_labelseq_prop {#1} \l_tmpa_tl
            { \tl_set:NV #3 \l_tmpa_tl }
            { \tl_set:Nn #3 0 }
      }
      { \tl_set:Nx #3 { \zref@extract {#1} {#2} } }
  }

% {<label>}{<prop>}{<int var>}
\cs_new:Npn \__zrefcheck_get_asint:nnn #1#2#3
  {
    \__zrefcheck_get_astl:nnn {#1} {#2} { \l__zrefcheck_prop_value_tl }
    % Make it an integer data type
    % FIXME We are not actually *checking* this conversion step succeeded in
    % any way.  We rely then on the use of this function to retrieve
    % properties which "we know" (!) to have integer values.  See if I can
    % introduce some verification and/or warning in case this step fails.
    \int_set:Nn #3 { \int_value:w \l__zrefcheck_prop_value_tl }
  }



%% Checks


% What is needed for a check to work?
%
% First, a conditional/predicate function defined with:
%
% \prg_new_protected_conditional:Npnn \__zrefcheck_check_<check>:nn #1#2 { T , F , TF }
%
% where "<check>", it the name of the check, the first argument is the "label"
% and the second the "reference".  The existence of the check is verified by
% the existence of the function with this name-scheme (and signatures).  Of
% course, this function must return either '\prg_return_true:' or
% '\prg_return_false:'. (It doesn-t *need* to be 'protected' if the content of
% the test does not require it, but the package does not expect the
% '\__zrefcheck_check_<check>_p:nn' variant to exist).
%
% Note that the naming convention of the checks adopts the perspective of the
% "reference".  That is, the "before" check should return true if the "label"
% occurs before the "reference".
%
% The checks it does are expected to retrieve 'zref's label information with
% '\__zrefcheck_get:nn' (zref extract infrastructure is, naturally, also an
% alternative for the regular properties).  Also, technically speaking, the
% "reference" argument is also a label, actually a pair of them, as set by
% '\zrefcheck'.  For the "labels", any 'zref' property in 'zref's main list is
% available, the "references" store the properties in the 'zrefcheck' list.
% Besides those, there is also the 'labelseq' (fake) property (for either
% "labels" or "references"), as provided by '\__zrefcheck_process_labelseq:',
% and stored in '\g__zrefcheck_auxfile_labelseq_prop'.
%
% Second, the required properties of labels and references must be duly
% registered for 'zref'.  This can be done with '\zref@newprop',
% '\zref@addprop' and friends, as usual.



% {<check>}{<label>}{<reference>}
\cs_new:Npn \__zrefcheck_do_check:nnn #1#2#3
  {
    \use:c { __zrefcheck_check_ #1 :nnF } {#2} {#3}
      { \msg_warning:nnnn { zrefcheck } { check-failed } {#1} {#2} }
  }

\cs_generate_variant:Nn \__zrefcheck_do_check:nnn { nnx }


\msg_new:nnn { zrefcheck } { check-failed }
  { The~check~'#1'~for~label~'#2'~has~failed.}


% More readable scratch variables for the tests
\int_new:N \l__zrefcheck_lbl_int
\int_new:N \l__zrefcheck_ref_int
\int_new:N \l__zrefcheck_lbl_b_int
\int_new:N \l__zrefcheck_ref_b_int


\prg_new_protected_conditional:Npnn \__zrefcheck_check_thispage:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \__zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \__zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_if:nTF
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int } &&
          % '0' is the default value of 'abspage' property, and this value
          % should not happen normally for this property, since even the first
          % page, after it gets shipped out, will store '1'.  So, if we do
          % find '0' here, better signal something is wrong.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
       }
       { \group_insert_after:N \prg_return_true:  }
       { \group_insert_after:N \prg_return_false: }
    \group_end:
  }
