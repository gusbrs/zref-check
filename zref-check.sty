
\ProvidesExplPackage {zref-check} {2021-07-19} { }
  {Flexible cross-references with contextual checks based on zref}

%% chapter{Dependencies}

\RequirePackage { zref-user }
\RequirePackage { zref-abspage }
\RequirePackage { ifdraft }


%% chapter{zref setup}

% Provide absolute counters for section and chapter, and respective zref
% properties, so that we can make checks about relation of chapters/sections
% regardless of internal counters, since we don't get those for the unnumbered
% (starred) ones.  About the proper place to make the hooks for this purpose,
% see https://tex.stackexchange.com/q/605533/105447, thanks Ulrike.

\int_new:N \g__zrefcheck_abschap_int
\int_new:N \g__zrefcheck_abssec_int

% If the documentclass does not define '\chapter' the only thing that happens
% is that the chapter counter is never incremented, and the section one never
% reset.
\AddToHook { cmd / chapter / before }
  {
    \int_gincr:N \g__zrefcheck_abschap_int
    \int_zero:N \g__zrefcheck_abssec_int
  }

\zref@newprop { abschap } [0] { \int_use:N \g__zrefcheck_abschap_int }
\zref@addprop \ZREF@mainlist { abschap }

\AddToHook { cmd / section / before }
  { \int_gincr:N \g__zrefcheck_abssec_int }

\zref@newprop { abssec } [0] { \int_use:N \g__zrefcheck_abssec_int }
\zref@addprop \ZREF@mainlist { abssec }


% This is the list of properties to be used by the '\zrefcheck' command, that
% is, the list of properties the *references* store.  This is the minimum set
% required, more properties may be added according to options.
\zref@newlist { zrefcheck }
\zref@addprops { zrefcheck }
  {
    abspage ,
    abschap ,
    abssec ,
    page % for messages
  }


%% chapter{Plumbing}

%%% section{Messages}

\cs_new_protected:Npn \__zrefcheck_message:nnnn #1#2#3#4
  {
    \use:c { msg_ \l__zrefcheck_msglevel_tl :nnnnn }
      { zref-check } {#1} {#2} {#3} {#4}
  }

\cs_generate_variant:Nn \__zrefcheck_message:nnnn { nnnx }

\msg_new:nnn { zref-check } { check-failed }
  { Failed~check~'#1'~for~label~'#2'~on~page~#3~on~input~line~\msg_line_number:. }

\msg_new:nnn { zref-check } { double-check }
  { Double-check~'#1'~for~label~'#2'~on~page~#3~on~input~line~\msg_line_number:. }


\msg_new:nnn { zref-check } { check-missing }
  { Check~'#1'~not~defined~on~input~line~\msg_line_number:. }

\msg_new:nnn { zref-check } { property-undefined }
  { Property~'#1'~not~defined~on~input~line~\msg_line_number:. }

\msg_new:nnn { zref-check } { property-not-in-label }
  { Label~'#1'~has~no~property~'#2'~on~input~line~\msg_line_number:. }

\msg_new:nnn { zref-check } { property-not-integer }
  { Property~'#1'~for~label~'#2'~not~an~integer~on~input~line~\msg_line_number:. }


\msg_new:nnn { zref-check } { hyperref-preamble-only }
  {
    Option~'hyperref'~only~available~in~the~preamble. \\
    Use~the~starred~version~of~'\protect\zrcheck'~instead.
  }

\msg_new:nnn { zref-check } { missing-hyperref }
  { Missing~'hyperref'~package. \\ Setting~'hyperref=false'. }

\msg_new:nnn { zref-check } { ignore-document-only }
  {
    Option~'ignore'~only~available~in~the~document. \\
    Use~option~'msglevel'~instead.
  }


%%% section{Options}

% 'hyperref' option

\bool_new:N \l__zrefcheck_use_hyperref_bool
\bool_new:N \l__zrefcheck_warn_hyperref_bool

\keys_define:nn { zref-check }
  {
    hyperref .choice: ,
    hyperref / auto .code:n =
      {
        \bool_set_true:N \l__zrefcheck_use_hyperref_bool
        \bool_set_false:N \l__zrefcheck_warn_hyperref_bool
      } ,
    hyperref / true .code:n =
      {
        \bool_set_true:N \l__zrefcheck_use_hyperref_bool
        \bool_set_true:N \l__zrefcheck_warn_hyperref_bool
      } ,
    hyperref / false .code:n =
      {
        \bool_set_false:N \l__zrefcheck_use_hyperref_bool
        \bool_set_false:N \l__zrefcheck_warn_hyperref_bool
      } ,
    hyperref .default:n = auto
  }

\AtBeginDocument
  {
    \@ifpackageloaded { hyperref }
      {
        \bool_if:NT \l__zrefcheck_use_hyperref_bool
          {
            \RequirePackage { zref-hyperref }
            \zref@addprop { zrefcheck } { anchor }
          }
      }
      {
        \bool_if:NT \l__zrefcheck_warn_hyperref_bool
          { \msg_warning:nn { zref-check } { missing-hyperref } }
        \bool_set_false:N \l__zrefcheck_use_hyperref_bool
      }
    \keys_define:nn { zref-check }
      {
        hyperref .code:n =
          { \msg_warning:nn { zref-check } { hyperref-preamble-only } }
      }
  }


% 'msglevel' option
\tl_new:N \l__zrefcheck_msglevel_tl

\keys_define:nn { zref-check }
  {
    msglevel .choice: ,
    msglevel / warn .code:n =
      { \tl_set:Nn \l__zrefcheck_msglevel_tl { warning } } ,
    msglevel / info .code:n =
      { \tl_set:Nn \l__zrefcheck_msglevel_tl { info } } ,
    msglevel / none .code:n =
      { \tl_set:Nn \l__zrefcheck_msglevel_tl { none } } ,
    msglevel / obeydraft .code:n =
      {
        \ifdraft
          { \tl_set:Nn \l__zrefcheck_msglevel_tl { info } }
          { \tl_set:Nn \l__zrefcheck_msglevel_tl { warning } }
      } ,
    msglevel / obeyfinal .code:n =
      {
        \ifoptionfinal
          { \tl_set:Nn \l__zrefcheck_msglevel_tl { warning } }
          { \tl_set:Nn \l__zrefcheck_msglevel_tl { info } }
      } ,
    % 'ignore' alias for 'msglevel=none'
    ignore .code:n =
      { \msg_warning:nn { zref-check } { ignore-document-only } }
  }

\AtBeginDocument
  {
    \keys_define:nn { zref-check }
      {
        ignore .code:n =
          { \keys_set:nn { zref-check } { msglevel = none } }
      }
  }


% 'onpage' option
\bool_new:N \l__zrefcheck_msgonpage_bool

\keys_define:nn { zref-check }
  {
    onpage .choice: ,
    onpage / labelseq .code:n =
      {
        \bool_set_false:N \l__zrefcheck_msgonpage_bool
      } ,
    onpage / msg .code:n =
      {
        \bool_set_true:N \l__zrefcheck_msgonpage_bool
      } ,
    onpage / obeydraft .code:n =
      {
        \ifdraft
          { \bool_set_false:N \l__zrefcheck_msgonpage_bool }
          { \bool_set_true:N \l__zrefcheck_msgonpage_bool }
      } ,
    onpage / obeyfinal .code:n =
      {
        \ifoptionfinal
          { \bool_set_true:N \l__zrefcheck_msgonpage_bool }
          { \bool_set_false:N \l__zrefcheck_msgonpage_bool }
      }
  }


% 'closerange' option
\int_new:N \l__zrefcheck_close_range_int

\keys_define:nn { zref-check }
  {
    closerange .int_set:N = \l__zrefcheck_close_range_int ,
  }


% Set load-time default values
\keys_set:nn { zref-check }
  {
    hyperref   = auto ,
    msglevel   = warn ,
    onpage     = labelseq ,
    closerange = 5
  }

% Process load-time package options
% https://tex.stackexchange.com/a/15840
\RequirePackage { l3keys2e }
\ProcessKeysOptions { zref-check }


% Provide '\zrchecksetup'
\NewDocumentCommand \zrchecksetup { m }
  { \keys_set:nn { zref-check } {#1} }


%%% section{Position on page}

% Method for determining relative position within the page: the sequence in
% which the labels get shipped out, inferred from the sequence in which the
% labels occur in the .aux file.
%
% Some relevant info about the sequence of things:
% https://tex.stackexchange.com/a/120978 and 'texdoc lthooks', section "Hooks
% provided by \begin{document}".


% One first attempt at this was to use '\zref@newlabel', which is the macro in
% which 'zref' stores the label information in the aux file.  When the .aux
% file is read at the beginning of the compilation, this macro is expanded for
% each of the labels.  So, by redefining this macro we can feed a variable (a
% L3 sequence), and then do what it usually does, which is to define each
% label with the internal macro '\@newl@bel', when the .aux file is read.
%
% Patching this macro for this is not possible.  First, '\zref@newlabel' is
% one of those "commands that look ahead" mentioned in 'ltcmdhooks'
% documentation.  Indeed, '\@newl@bel' receives 3 arguments, and
% '\zref@newlabel' just passes the first, the following two will be scanned
% ahead.  Second, the 'ltcmdhooks' hooks are not actually available when the
% .aux file is read, they come only after '\begin{document}'.  Hence,
% redefinition would be the only alternative.  My attempts at this ended up
% registered at https://tex.stackexchange.com/a/604744.  But the best result
% in these lines was:
%
% \ZREF@Robust\edef\zref@newlabel#1{
%   \noexpand\seq_gput_right:Nn \noexpand\g__zrefcheck_auxfile_lblseq_seq {#1}
%   \noexpand\@newl@bel{\ZREF@RefPrefix}{#1}
% }


% However, better than the above is to just read it from the .aux file
% directly, no need to redefine anything.  That's what David Carlisle's answer
% at https://tex.stackexchange.com/a/147705 does.  This answer has actually
% been converted into the package 'listlbls' by Norbert Melzer, but it is made
% to work with regular labels, not with 'zref's.  And it also does not really
% expose the information in a retrievable way (as far as I can tell).  So, the
% below is adapted from Carlisle's answer's technique (a poor man's version of
% it...).
%
% There is some subtlety here as to whether this approach makes it safe for us
% to read the labels at this point without '\zref@wrapper@babel'.  The common
% wisdom is that babel's shorthands are only active after '\begin{document}'
% (e.g., https://tex.stackexchange.com/a/98897).  Alas, it is more complicated
% than that.  Babel's documentation says (in section 9.5 Shorthands): "To
% prevent problems with the loading of other packages after babel we reset the
% catcode of the character to the original one at the end of the package and
% of each language file (except with KeepShorthandsActive).  It is
% re-activate[d] again at \begin{document}.  We also need to make sure that
% the shorthands are active during the processing of the .aux file.  Otherwise
% some citations may give unexpected results in the printout when a shorthand
% was used in the optional argument of \bibitem for example."  This is done
% with '\if@filesw \immediate\write\@mainaux{...}'.  In other words, the
% catcode change is written in the .aux file itself!  Indeed, if you inspect
% the file, you'll find them there.  Besides, there is still the ominous
% "except with KeepShorthandsActive".
%
% However, the *method* I'm using here is not quite the same as the usual run
% of the .aux file, because I'm actively discarding the lines for which the
% first token is not equal to '\zref@newlabel'.  I have tested the famous
% sensitive case for this: 'babel' with 'french' and labels with colons.  And
% I was able to retrieve the information as expected.  Well, *if*
% 'KeepShorthandsActive' is enabled *with 'french'* and we load the package
% *after babel* things do break, but not quite because of the colons in the
% labels.  Even 'siunitx' breaks in the same conditions...
%
% For reference: About what are valid characters for use in labels:
% https://tex.stackexchange.com/a/18312.  About some problems with active
% colons: https://tex.stackexchange.com/a/89470.
%
% About the difference between L3 strings and token lists, see
% https://tex.stackexchange.com/a/446381, in particular Joseph Wright's
% comment: "Strings are for data that will never be typeset, for example file
% names, identifiers, etc.: if the material may be used in typesetting, it
% should be a token list."  See also moewe's (CW) answer in the same lines.
% Which suggests using L3 strings for the reference labels might be a good
% catch all approach, and possibly more robust.  David Carlisle's comment
% about 'inputenc' is a caveat (see
% https://tex.stackexchange.com/q/446123#comment1516961_446381).
% Still... let's stick to tradition as long as it works, 'zref' already does a
% great job here anyway.

\prop_new:N \g__zrefcheck_auxfile_lblseq_prop

\tl_set:Nn \g_tmpa_tl { \c_sys_jobname_str .aux }
\file_if_exist:nT { \g_tmpa_tl }
  {
    % Retrieve the information from the .aux file, and store it in a property
    % list, so that the sequence can be retrieved in key-value fashion.
    \ior_open:Nn \g_tmpa_ior { \g_tmpa_tl }
    \group_begin:
      \int_zero:N \l_tmpa_int
      \tl_clear:N \l_tmpa_tl
      \tl_clear:N \l_tmpb_tl
      \bool_set_false:N \l_tmpa_bool
      \ior_map_variable:NNn \g_tmpa_ior \l_tmpa_tl
        {
          \tl_map_variable:NNn \l_tmpa_tl \l_tmpb_tl
            {
              \tl_if_eq:NnTF \l_tmpb_tl { \zref@newlabel }
                {
                  % Found a zref@label, signal it.
                  \bool_set_true:N \l_tmpa_bool
                }
                {
                  \bool_if:NTF \l_tmpa_bool
                    {
                      \bool_set_false:N \l_tmpa_bool
                      \int_incr:N \l_tmpa_int
                      \prop_gput:Nxx \g__zrefcheck_auxfile_lblseq_prop
                        { \l_tmpb_tl } { \int_use:N \l_tmpa_int }
                    }
                    {
                      % If there is not a match of the first token with
                      % '\zref@newlabel', break the loop and discard the rest
                      % of the line, to ensure no babel calls to '\catcode' in
                      % the .aux file get expanded.  This also breaks the loop
                      % and discards the rest of the '\zref@newlabel' lines
                      % after we got the label we wanted, since we reset
                      % '\l_tmpa_bool' in the 'T' branch.
                      \tl_map_break:
                    }
                }
            }
        }
    \group_end:
    \ior_close:N \g_tmpa_ior
  }


% The alternate method I had considered (more than that...) for this was using
% yx coordinates supplied by 'zref's 'savepos' module.  However, this approach
% brought in a number of complexities, including the need to patch either
% '\zref@label' or '\ZREF@label'.  In addition, the technique was at the
% bottom fundamentally flawed.  Ulrike Fischer was very much right when she
% said that "structure and position are two different beasts"
% (https://github.com/ho-tex/zref/issues/12#issuecomment-880022576).  It is
% true that the checks based on it behaved decently, in normal circumstances,
% and except for outrageous label placement by the user, it would return the
% expected results.  We don't really need exact coordinates to decide
% "above/below".  Besides, it would do an exact job for the dedicated target
% macros of this package.  However, I could not conceive a situation where the
% 'yx' criterion would perform clearly better than the 'labeseq' one.  And, if
% that's the case, and considering the complications it brings, this check was
% a slippery slope.  All in all, I've decided to drop it.


%%% section{Counter}

% We need a dedicated counter for the labels generated by the checks and
% targets.  The value of the counter is not relevant, we just need it to be
% able to set proper anchors with '\refstepcounter'.  And, since I couldn't
% find a '\refstepcounter' equivalent in L3, we use a standard 2e counter
% here.  I'm also using the technique to ensure the counter is never reset
% that is used by 'zref-abspage.sty' and '\zref@require@unique'.  I don't know
% why it is needed, but if Oberdiek does it, there must be a reason.  In any
% case, the requirements are the same, we need numbers ensured to be *unique*
% in the counter.

\begingroup
  \let \@addtoreset \ltx@gobbletwo
  \newcounter { zrefcheck }
\endgroup
\setcounter { zrefcheck } { 0 }


%%% section{Label formats}

% {<check id int>}
\cs_new:Npn \__zrefcheck_check_lblfmt:n #1
  { zrefcheck@ \int_use:N #1 }

% {<label>}
\cs_new:Npn \__zrefcheck_end_lblfmt:n #1
  { #1 @zrefcheck }


%%% section{Property values}

% A convenience function to retrieve property values from labels.  Uses
% '\g__zrefcheck_auxfile_lblseq_prop' for "lblseq", and calls
% '\zref@extract' for everything else.
%
% We cannot use the return value of '\__zrefcheck_get_as(tl|int):nnn'
% directly, because we need to use the retrieved property values as arguments
% in the checks, however we use here a number of non-expandable operations.
% Hence, we receive a local tl/int variable as third argument and set that, so
% that it is available (and expandable) at the place of use.  For this reason,
% we do not group here, because we are passing a local variable around, but it
% is expected this function will be called within a group.
%
% I'm returning '\c_empty_tl' in case of failure to find the intended property
% value (explicitly in '\zref@extractdefault', but that is also what
% '\tl_clear:N' does).


% {<label>}{<prop>}{<tl var>}
\cs_new:Npn \zrefcheck_get_astl:nnn #1#2#3
  {
    \tl_clear:N #3
    \tl_if_eq:nnTF {#2} { lblseq }
      {
        \prop_get:NnNF \g__zrefcheck_auxfile_lblseq_prop {#1} #3
          {
            \msg_warning:nnnn { zref-check }
              { property-not-in-label } {#1} {#2}
          }
      }
      {
        % There are three things we need to check to ensure the information we
        % are trying to retrieve here exists: the existence of "label", the
        % existence of "property", and whether the particular label being
        % queried actually contains the property.  If that's all in place, the
        % value is passed to the checks, and it's their responsibility to
        % verify the consistency of this value.
        %
        % The existence of the label is an user facing issue, and a warning
        % for this is placed in '\_zrefcheck:nnnnn' (and done with
        % '\zref@refused').  We do check here though for definition with
        % '\zref@ifrefundefined' and silently do nothing if it is undefined,
        % to reduce irrelevant warnings in a fresh compilation round.  The
        % other two are more "internal" problems, either some problem with the
        % checks, or with the configuration of 'zref' for their consumption.
        \zref@ifrefundefined {#1}
          {}
          {
            \zref@ifpropundefined {#2}
              { \msg_warning:nnnn { zref-check } { property-undefined } {#2} }
              {
                \zref@ifrefcontainsprop {#1} {#2}
                  {
                    \tl_set:Nx #3
                      { \zref@extractdefault {#1} {#2} { \c_empty_tl } }
                  }
                  {
                    \msg_warning:nnnn
                      { zref-check } { property-not-in-label } {#1} {#2}
                  }
              }
          }
      }
  }



% '\zrefcheck_get_asint:nnn' is a very convenient wrapper around the more
% general '\zrefcheck_get_astl:nnn', since almost always we'll be wanting to
% compare numbers in the checks.  However, it is quite hard for it to ensure
% an integer is *always* returned in the case of errors.  And those do occur,
% even in a well structured document (e.g., in a first round of compilation).
% To complicate things, the L3 integer predicates are *very* sensitive to
% receiving any other kind of data, and they *scream*.  To handle this
% '\zrefcheck_get_asint:nnn' uses '\l__zrefcheck_integer_bool'.  To use this
% function always set '\l__zrefcheck_integer_bool' to true first, then call it
% as much as you need.  If any of these calls got is returning anything which
% is not an integer, '\l__zrefcheck_integer_bool' will have been set to false,
% and you should check that this hasn't happened before actually comparing the
% integers ('\bool_lazy_and:nnTF' is your friend).
\bool_new:N \l__zrefcheck_integer_bool

\tl_new:N \l__zrefcheck_propval_tl

% {<label>}{<prop>}{<int var>}
\cs_new:Npn \zrefcheck_get_asint:nnn #1#2#3
  {
    \zrefcheck_get_astl:nnn {#1} {#2} { \l__zrefcheck_propval_tl }
    \__zrefcheck_is_integer:nTF { \l__zrefcheck_propval_tl }
      {
        % Make it an integer data type
        \int_set:Nn #3 { \int_eval:n { \l__zrefcheck_propval_tl } }
      }
      {
        \bool_set_false:N \l__zrefcheck_integer_bool
        % Keep silent if ref is undefined to reduce irrelevant warnings in a
        % fresh compilation round.  Again, this is also not the point to check
        % for undefined references, that's a task for '\_zrefcheck:nnnnn'.
        \zref@ifrefundefined {#1}
          { }
          {
            \msg_warning:nnnn { zref-check }
              { property-not-integer } {#2} {#1}
          }
      }
  }

% Thanks egreg: https://tex.stackexchange.com/a/244405
\prg_new_conditional:Npnn \__zrefcheck_is_integer:n #1 { p, T, F, TF }
  {
    \tl_if_empty:oTF {#1}
      { \prg_return_false: } % empty tl is also not an integer
      {
        \tl_if_blank:oTF { \__int_to_roman:w -0#1 }
          { \prg_return_true:  }
          { \prg_return_false: }
      }
  }



%% chapter{zrcheck}

% *[<options>]{<labels>}[<checks>]{<text>}
\NewDocumentCommand \zrcheck
  { s O { } > { \SplitList { , } } m > { \SplitList { , } } O { } +m }
  { \zref@wrapper@babel \_zrefcheck:nnnnn {#3} {#1} {#2} {#4} {#5} }

\int_new:N \g__zrefcheck_id_int
\tl_new:N \l__zrefcheck_checkbeg_tl
\tl_new:N \l__zrefcheck_checkend_tl
\tl_new:N \l__zrefcheck_link_label_tl
\tl_new:N \l__zrefcheck_link_anchor_tl
\bool_new:N \l__zrefcheck_link_star_tl

% An intermediate internal function, which places "labels" as first argument,
% so that it can be protected by '\zref@wrapper@babel'.  This is more or less
% what the definition of '\zref' in 'zref-user.sty' does for this.
% {<labels>}*[<options>][<checks>]{<text>}
\cs_new_protected:Npn \_zrefcheck:nnnnn #1#2#3#4#5
  {
    \int_gincr:N \g__zrefcheck_id_int
    \mode_leave_vertical:
    \group_begin:

      % Process local options
      \keys_set:nn { zref-check } {#3}

      % Names of the labels for this zrefcheck call
      \tl_set:Nx \l__zrefcheck_checkbeg_tl
        { \__zrefcheck_check_lblfmt:n { \g__zrefcheck_id_int } }
      \tl_set:Nx \l__zrefcheck_checkend_tl
        { \__zrefcheck_end_lblfmt:n { \l__zrefcheck_checkbeg_tl } }

      % Set checkbeg label
      \refstepcounter { zrefcheck }
      \zref@labelbylist { \l__zrefcheck_checkbeg_tl } { zrefcheck }

      % Typeset "<text>", with hyperlink when appropriate.

      % Even though the first argument can receive a list of labels, there is
      % no meaningful way to set links to multiple targets.  Hence, only the
      % first one is considered for hyperlinking.
      \tl_set:Nn \l__zrefcheck_link_label_tl { \tl_item:nn {#1} {1} }

      \bool_set:Nn \l__zrefcheck_link_star_tl {#2}
      \zref@ifrefundefined { \l__zrefcheck_link_label_tl }
        {#5} % If the reference is undefined, just typeset.
        {
          \bool_if:nTF
            {
              \l__zrefcheck_use_hyperref_bool &&
              ! \l__zrefcheck_link_star_tl
            }
            {
              \exp_args:Nx \zrefcheck_get_astl:nnn
                { \l__zrefcheck_link_label_tl }
                { anchor } { \l__zrefcheck_link_anchor_tl }
              \hyperlink { \l__zrefcheck_link_anchor_tl } {#5}
            }
            {#5}
        }

      % Set checkend label
      \refstepcounter { zrefcheck }
      \zref@labelbylist { \l__zrefcheck_checkend_tl } { zrefcheck }

      % Check definition
      \tl_map_function:nN {#1} \zref@refused

      % Run the checks
      \__zrefcheck_run_checks:nnV {#4} {#1} { \l__zrefcheck_checkbeg_tl }

    \group_end:
  }


%% chapter{Targets}

% {<label>}{<text>}
\NewDocumentCommand \zrctarget { m +m }
  {
    \refstepcounter { zrefcheck }
    \zref@wrapper@babel \zref@labelbylist {#1} { zrefcheck }
    #2
    \refstepcounter { zrefcheck }
    \zref@wrapper@babel
      \zref@labelbylist { \__zrefcheck_end_lblfmt:n {#1} } { zrefcheck }
  }

% {<label>}
\NewDocumentEnvironment {zrcregion} { m }
  {
    \refstepcounter { zrefcheck }
    \zref@wrapper@babel \zref@labelbylist {#1} { zrefcheck }
  }
  {
    \refstepcounter { zrefcheck }
    \zref@wrapper@babel
      \zref@labelbylist { \__zrefcheck_end_lblfmt:n {#1} } { zrefcheck }
  }


%% chapter{Checks}

% What is needed for a check to work?
%
% First, a conditional/predicate function defined with:
%
% \prg_new_conditional:Npnn \__zrefcheck_check_<check>:nn #1#2 { F }
%
% where "<check>", it the name of the check, the first argument is the "label"
% and the second the "reference".  The existence of the check is verified by
% the existence of the function with this name-scheme (and signatures).  Of
% course, this function must return either '\prg_return_true:' or
% '\prg_return_false:'.  Of course, you can define other variants if you need
% internally, and may do a protected definition, if it is needed for the
% content of the check, just what the package does expect and verifies is
% existence of the ':nnF' variant.
%
% Note that the naming convention of the checks adopts the perspective of the
% "reference".  That is, the "before" check should return true if the "label"
% occurs before the "reference".
%
% The checks it does are expected to retrieve 'zref's label information with
% '\zrefcheck_get_astl:nnn' or '\zrefcheck_get_asint:nnn'.  Also, technically
% speaking, the "reference" argument is also a label, actually a pair of them,
% as set by '\zrcheck'.  For the "labels", any 'zref' property in 'zref's main
% list is available, the "references" store the properties in the 'zrefcheck'
% list.  Besides those, there is also the 'lblseq' (fake) property (for either
% "labels" or "references"), stored in '\g__zrefcheck_auxfile_lblseq_prop'.
%
% Second, the required properties of labels and references must be duly
% registered for 'zref'.  This can be done with '\zref@newprop',
% '\zref@addprop' and friends, as usual.


%%% section{Running}

% {<list of checks>}{<list of labels>}{<reference>}
\cs_new:Npn \__zrefcheck_run_checks:nnn #1#2#3
  {
    \group_begin:
      \tl_map_inline:nn {#2}
        {
          \tl_map_inline:nn {#1}
            { \__zrefcheck_do_check:nnn {####1} {##1} {#3} }
        }
    \group_end:
  }

\cs_generate_variant:Nn \__zrefcheck_run_checks:nnn { nnV }


\bool_new:N \l__zrefcheck_passedcheck_bool
\bool_new:N \l__zrefcheck_onpage_bool
\tl_new:N \l__zrefcheck_labelend_tl
\seq_set_from_clist:Nn \c__zrefcheck_onpage_checks_seq
  { above , below , before , after }

\cs_generate_variant:Nn \exp_args:Nnno { Nnoo }

% {<check>}{<label beg>}{<reference beg>}
\cs_new:Npn \__zrefcheck_do_check:nnn #1#2#3
  {
    \group_begin:
      % "label beg" may be defined or not, it is arbitrary user input.
      % Whether this is the case is checked in '\_zrefcheck:nnnnn', and due
      % warning already ensues.  And there is no point in checking "relative
      % position" of an undefined label.  Hence, in the absence of '#2', we do
      % nothing at all here.
      \zref@ifrefundefined {#2}
        {}
        {
          \bool_set_true:N \l__zrefcheck_passedcheck_bool
          \bool_set_false:N \l__zrefcheck_onpage_bool
          \cs_if_exist:cTF { __zrefcheck_check_ #1 :nnF }
            {
              % "label beg" vs "reference beg"
              \use:c { __zrefcheck_check_ #1 :nnF }
                {#2} {#3}
                { \bool_set_false:N \l__zrefcheck_passedcheck_bool }
              % "label beg" vs "reference end"
              \exp_args:Nnno \use:c { __zrefcheck_check_ #1 :nnF }
                {#2} { \__zrefcheck_end_lblfmt:n {#3} }
                { \bool_set_false:N \l__zrefcheck_passedcheck_bool }
              % "label end" *may* have been created by the target commands
              \zref@ifrefundefined { \__zrefcheck_end_lblfmt:n {#2} }
                { \tl_set:Nn \l__zrefcheck_labelend_tl {#2} }
                {
                  % "label end" vs "reference beg"
                  \exp_args:Nno \use:c { __zrefcheck_check_ #1 :nnF }
                    { \__zrefcheck_end_lblfmt:n {#2} } {#3}
                    { \bool_set_false:N \l__zrefcheck_passedcheck_bool }
                  % "label end" vs "reference end"
                  \exp_args:Nnoo \use:c { __zrefcheck_check_ #1 :nnF }
                    { \__zrefcheck_end_lblfmt:n {#2} }
                    { \__zrefcheck_end_lblfmt:n {#3} }
                    { \bool_set_false:N \l__zrefcheck_passedcheck_bool }
                  \tl_set:Nx \l__zrefcheck_labelend_tl
                    { \__zrefcheck_end_lblfmt:n {#2} }
                }
              % Handle option 'onpage=msg'.  This is only granted for tests
              % which perform "within this page" checks ('above', 'below',
              % 'before', 'after') *and* if all labels are "within this page".
              % If both conditions are met, signal.
              \seq_if_in:NnT \c__zrefcheck_onpage_checks_seq {#1}
                {
                  \__zrefcheck_check_thispage:nnT
                    {#2} { \__zrefcheck_end_lblfmt:n {#3} }
                    {
                      \__zrefcheck_check_thispage:nnT
                        { \l__zrefcheck_labelend_tl } {#3}
                        { \bool_set_true:N \l__zrefcheck_onpage_bool }
                    }
                }
              \bool_if:NTF \l__zrefcheck_passedcheck_bool
                {
                  \bool_if:nT
                    {
                      \l__zrefcheck_msgonpage_bool &&
                      \l__zrefcheck_onpage_bool
                    }
                    {
                      \__zrefcheck_message:nnnx
                        { double-check } {#1} {#2} { \zref@extract {#3} {page} }
                    }
                }
                {
                  \__zrefcheck_message:nnnx
                    { check-failed } {#1} {#2} { \zref@extract {#3} {page} }
                }
            }
            { \msg_warning:nnn { zref-check } { check-missing } {#1} }
        }
    \group_end:
  }


%%% section{Definitions}

% More readable scratch variables for the tests
\int_new:N \l__zrefcheck_lbl_int
\int_new:N \l__zrefcheck_ref_int


%%%% subsection{This page}

\prg_new_protected_conditional:Npnn \__zrefcheck_check_thispage:nn #1#2 { T, F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int } &&
            % '0' is the default value of 'abspage' property, and this
            % value should not happen normally for this property, since
            % even the first page, after it gets shipped out, will store
            % '1'.  So, if we do find '0' here, better signal something is
            % wrong.
            ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
            ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }


%%%% subsection{On page}

\prg_new_protected_conditional:Npnn \__zrefcheck_check_above:nn #1#2 { F , TF }
  {
    \group_begin:
      \__zrefcheck_check_thispage:nnTF {#1} {#2}
        {
          \bool_set_true:N \l__zrefcheck_integer_bool
          \zrefcheck_get_asint:nnn {#1} { lblseq } { \l__zrefcheck_lbl_int }
          \zrefcheck_get_asint:nnn {#2} { lblseq } { \l__zrefcheck_ref_int }
          \bool_lazy_and:nnTF
            { \l__zrefcheck_integer_bool }
            {
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } < { \l__zrefcheck_ref_int } &&
              ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
              ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
            }
            { \group_insert_after:N \prg_return_true:  }
            { \group_insert_after:N \prg_return_false: }
        }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_below:nn #1#2 { F , TF }
  {
    \__zrefcheck_check_above:nnTF {#1} {#2}
      { \prg_return_false: }
      { \prg_return_true:  }
  }


%%%% subsection{Before / After}

\prg_new_protected_conditional:Npnn \__zrefcheck_check_before:nn #1#2 { F }
  {
    \__zrefcheck_check_pagesbefore:nnTF {#1} {#2}
      { \prg_return_true: }
      {
        \__zrefcheck_check_above:nnTF {#1} {#2}
          { \prg_return_true:  }
          { \prg_return_false: }
      }
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_after:nn #1#2 { F }
  {
    \__zrefcheck_check_pagesafter:nnTF {#1} {#2}
      { \prg_return_true: }
      {
        \__zrefcheck_check_below:nnTF {#1} {#2}
          { \prg_return_true:  }
          { \prg_return_false: }
      }
  }


%%%% subsection{Pages}

\prg_new_protected_conditional:Npnn \__zrefcheck_check_nextpage:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int + 1 } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_prevpage:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int - 1 } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_pagesbefore:nn #1#2 { F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } < { \l__zrefcheck_ref_int } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\cs_new_eq:NN \__zrefcheck_check_ppbefore:nnF \__zrefcheck_check_pagesbefore:nnF

\prg_new_protected_conditional:Npnn \__zrefcheck_check_pagesafter:nn #1#2 { F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } > { \l__zrefcheck_ref_int } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\cs_new_eq:NN \__zrefcheck_check_ppafter:nnF \__zrefcheck_check_pagesafter:nnF

\prg_new_protected_conditional:Npnn \__zrefcheck_check_facing:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          % There exists no "facing" page if the document is not twoside.
          \legacy_if_p:n { @twoside } &&
          % Now we test "facing"
          (
            (
              \int_if_odd_p:n { \l__zrefcheck_ref_int } &&
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int - 1 }
            ) ||
            (
              \int_if_even_p:n { \l__zrefcheck_ref_int } &&
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int + 1 }
            )
          ) &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }


%%%% subsection{Close / Far}

\prg_new_protected_conditional:Npnn \__zrefcheck_check_close:nn #1#2 { F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \int_abs:n { \l__zrefcheck_lbl_int - \l__zrefcheck_ref_int } }
            <
            { \l__zrefcheck_close_range_int + 1 } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_far:nn #1#2 { F }
  {
    \__zrefcheck_check_close:nnTF {#1} {#2}
      { \prg_return_false: }
      { \prg_return_true:  }
  }


%%%% subsection{Chapter}

\prg_new_protected_conditional:Npnn \__zrefcheck_check_thischap:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abschap } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abschap } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int } &&
          % '0' is the default value of 'abschap' property, and means here no
          % '\chapter' has yet been issued, therefore it cannot be "this
          % chapter", nor "the next chapter", nor "the previous chapter", it
          % is just "no chapter".  Note, however, that a statement about a
          % "future" chapter does not require the "current" one to exist.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_nextchap:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abschap } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abschap } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int + 1 } &&
          % Ditto. (Though redundant, in this case).
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_prevchap:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abschap } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abschap } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int - 1 } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_chapsafter:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abschap } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abschap } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } > { \l__zrefcheck_ref_int } &&
          % Ditto. (Though redundant, in this case).
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_chapsbefore:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abschap } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abschap } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } < { \l__zrefcheck_ref_int } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }


%%%% subsection{Section}

\prg_new_protected_conditional:Npnn \__zrefcheck_check_thissec:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abssec } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abssec } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int } &&
          % '0' is the default value of 'abssec' property, and means here no
          % '\section' has yet been issued since its counter has been reset,
          % which occurs at the beginning of the document and at every
          % chapter.  Hence, as is the case for chapters, '0' is just "not a
          % section".  The same observation about the need of the "current"
          % section to exist to be able to refer to a "future" one also holds.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_nextsec:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abssec } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abssec } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int + 1 } &&
          % Ditto. (Though redundant, in this case).
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_prevsec:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abssec } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abssec } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int - 1 } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_secsafter:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abssec } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abssec } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } > { \l__zrefcheck_ref_int } &&
          % Ditto. (Though redundant, in this case).
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_secsbefore:nn #1#2 { F }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \zrefcheck_get_asint:nnn {#1} { abssec } { \l__zrefcheck_lbl_int }
      \zrefcheck_get_asint:nnn {#2} { abssec } { \l__zrefcheck_ref_int }
      \bool_lazy_and:nnTF
        { \l__zrefcheck_integer_bool }
        {
          \int_compare_p:nNn
            { \l__zrefcheck_lbl_int } < { \l__zrefcheck_ref_int } &&
          % Ditto.
          ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
          ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
        }
        { \group_insert_after:N \prg_return_true:  }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }
