
% TODO Some info to check:
%
% About what are valid characters for use in labels:
% https://tex.stackexchange.com/a/18312.  About some problems with active
% colons: https://tex.stackexchange.com/a/89470


\ProvidesExplPackage {zref-check} {2021-07-06} { }
  {Flexible cross-references with relative position checks based on zref}

\RequirePackage { zref-user }
\RequirePackage { zref-abspage }
\RequirePackage { zref-savepos }
\RequirePackage { zref-hyperref }

\RequirePackage { zref-abschap }



% Constructed label formats

% {<check id int>}
\cs_new:Npn \__zrefcheck_checkbeg_lblfmt:n #1
  { zrefcheck@ \int_use:N #1 @beg }

% {<check id int>}
\cs_new:Npn \__zrefcheck_checkend_lblfmt:n #1
  { zrefcheck@ \int_use:N #1 @end }

% {<label tl>}
\cs_new:Npn \__zrefcheck_labelpos_lblfmt:n #1
  { zrefcheck@ #1 @pos }



% We need 'zref's label commands to issue '\zref@savepos' every time, and not
% just when using the 'savepos' module's commands, because we want every
% 'zlabel' to have proper coordinates.  For this reason, we have to run a call
% to '\zref@savepos' on a "before hook" to '\ZREF@label'.  However, since the
% required information (position on the page of the text to which the label
% refers to) is only known at shipout, we do this call under a dummy (writes
% nothing) call to '\protected@write' to execute '\zref@savepos' right before
% '\ZREF@label's job is done, emulating what this command does in this regard.
% I think this is somewhat institutionalized, see David Carlisle's comment at
% https://tex.stackexchange.com/a/98810 regarding the '#2' argument of
% '\protected@write'.  See also the discussion in egreg's answer to the same
% question.  Of course, that is also what '\ZREF@label' itself does and,
% ideally, we'd just place '\zref@savepos' inside it.
% \hook_gput_code:nnn { cmd / ZREF@label / before } { zrefcheck }
%   {
%     \if@filesw
%       \begingroup
%         \protected@write \@auxout {
%           \zref@savepos
%         }{}
%       \endgroup
%     \fi
%   }
%
% Add 'posx'/'posy' to the 'main' list properties, so that the labels created
% with the standard '\zlabel' from the 'user' module carries the position
% information.
% \zref@addprop \ZREF@mainlist { posx }
% \zref@addprop \ZREF@mainlist { posy }


% An alternate method to get the labels position is to hook into '\zref@label'
% instead, and from there call '\zsavepos' with a constructed label, which can
% later be retrieved.  This is better in all regards than the previous attempt
% of hooking on to '\ZREF@label' to run '\zref@savepos'.  I'm still patching a
% function I'd prefer not to, but it is less lower level and affects only
% '\zref@label' and '\zlabel' and not the rest of the programming API of
% 'zref'.  The problem with patching is, of course, that it reintroduces the
% old load order problems...  The hook to 'begindocument' should mitigate this
% a little, but certainly does not eliminate the issue.  Using 'zref's
% machinery not to mix the interfaces at this point.
\hook_gput_code:nnn { begindocument } { zrefcheck }
  {
    \ZREF@patch{zref@label}{
      \ZREF@Robust\def\zref@label#1{
        \zsavepos{ \__zrefcheck_labelpos_lblfmt:n {#1} }
        \ZREF@org@zref@label{#1}
      }
    }
  }



% This is the list of properties to be used by the '\zrefcheck' command.
\zref@newlist { zrefcheck }
\zref@addprops { zrefcheck }
  {
    % minimum set needed
    abspage ,
    abschap ,
    abssec ,
    % if page position is being used
    posx ,
    posy ,
    % for use in warning messages
    page
  }


% Alternate method for determining relative position: the sequence in which
% the labels get shipped out.  Sort of getting the sequence in which the
% labels occur in the .aux file.
%
% Some relevant info about the sequence of things:
% https://tex.stackexchange.com/a/120978 and 'texdoc lthooks', section "Hooks
% provided by \begin{document}".
%
% The basic idea for this is to use '\zref@newlabel', which is the macro
% 'zref' uses to store label information in the aux file.  When the .aux file
% is read at the beginning of the compilation, this macro is expanded for each
% of the labels.  So, we redefine this macro to feed a variable (a L3
% sequence), and then do what it usually does, which is to define each label
% with the internal macro '\@newl@bel', when the .aux file is read.  See
% https://tex.stackexchange.com/q/604265.
%
% I'd love to not have to redefine this macro, but use a patch instead.  It is
% not possible though.  First, '\zref@newlabel' is one of those "commands that
% look ahead" mentioned in 'ltcmdhooks' documentation. Indeed, '\@newl@bel'
% receives 3 arguments, and '\zref@newlabel' just passes the first, the
% following two will be scanned ahead.  Second, the 'ltcmdhooks' hooks are not
% actually available when the .aux file is read, they come only after
% '\begin{document}'.
%
% Ulrike Fischer (in the comments to https://tex.stackexchange.com/q/604265)
% suggested something like the below for this purpose.
%
% \cs_gset_protected:Npn \zref@newlabel #1#2
%   {
%     \seq_gput_right:Nn \g__zrefcheck_auxfile_labelseq_seq {#1}
%     \@newl@bel {\ZREF@RefPrefix} {#1} {#2}
%   }
%
% However, though this works, this is not exactly equivalent to the original
% definition.  The difference being that '\ZREF@RefPrefix' is actually not
% expanded at the definition, it is expanded later, when the macro is called.
% And that difference is precisely the reason for the use of '\edef' there in
% the first place.  If anyone were to redefine '\ZREF@RefPrefix' somewhere,
% things would go sour.  Ulrike certainly considered it, and actually
% suggested to hardcode "Z@R" there instead, but that poses problems of its
% own.  A more precise redefinition for '\zref@newlabel' is then the following
% (I have no idea how to do '\edef' in L3 syntax, it seems everything revolves
% around the expansion of the arguments.  There must be, I just don't know.)
%
% \ZREF@Robust\edef\zref@newlabel#1{
%   \noexpand\seq_gput_right:Nn \noexpand\g__zrefcheck_auxfile_labelseq_seq {#1}
%   \noexpand\@newl@bel{\ZREF@RefPrefix}{#1}
% }


% Even better, just read it from the aux file directly, no need to redefine
% anything.  Adapted from (poor man's version...) David Carlisle's answer
% https://tex.stackexchange.com/a/147705.  This has actually been converted
% into the package 'listlbls' by Norbert Melzer, but it is made to work with
% regular labels, not with 'zref's.  And it also does not really expose the
% information in a retrievable way, as far as I can tell.  See
% https://tex.stackexchange.com/a/604744.
%
% NOTE I'm not really sure this approach makes it safe for us to read the
% labels at this point without '\zref@wrapper@babel'.  The common wisdom is
% that babel's shorthands are only active after '\begin{document}' (e.g,
% https://tex.stackexchange.com/a/98897).  Alas, it is more complicated than
% that.  Babel's documentation says (in section 9.5 Shorthands): "To prevent
% problems with the loading of other packages after babel we reset the catcode
% of the character to the original one at the end of the package and of each
% language file (except with KeepShorthandsActive). It is re-activate again
% at \begin{document}. We also need to make sure that the shorthands are
% active during the processing of the .aux file. Otherwise some citations may
% give unexpected results in the printout when a shorthand was used in the
% optional argument of \bibitem for example."  This is done with
% '\AtBeginDocument{...\if@filesw \immediate\write\@mainaux{...}...}'.  In
% other words, the catcode change is written in the .aux file itself!
% Besides, of course, there is still "except with KeepShorthandsActive".
% However, the *method* I'm using here is not quite the same as the usual run
% of the .aux file, because I'm skipping the lines for which the first token
% is not equal to '\zref@newlabel'.  I have tested the famous sensitive case
% for this: 'babel' with 'french' and labels with colons.  And I was able to
% retrieve the information as expected.  Well, *if* 'KeepShorthandsActive' is
% enabled with 'french' *and* we load the package *after babel* things do
% break, but not quite because of the colons in the labels.  Even 'siunitx'
% breaks in the same conditions...

\prop_new:N \g__zrefcheck_auxfile_labelseq_prop

\tl_set:Nn \g_tmpa_tl { \c_sys_jobname_str .aux }
\file_if_exist:nT { \g_tmpa_tl }
  {
    % Retrieve the information from the .aux file, and store it in a property
    % list, so that the sequence can be retrieved in key-value fashion.
    \ior_open:Nn \g_tmpa_ior { \g_tmpa_tl }
    \group_begin:
      \int_zero:N \l_tmpa_int
      \ior_map_inline:Nn \g_tmpa_ior
        {
          \tl_set:Nn \l_tmpa_tl { \zref@newlabel }
          \tl_set:Nx \l_tmpb_tl { \tl_item:nn {#1} { 1 } }
          \tl_if_eq:NNT \l_tmpa_tl \l_tmpb_tl
            {
              \tl_set:Nx \l_tmpa_tl { \tl_item:nn {#1} { 2 } }
              \int_incr:N \l_tmpa_int
              \prop_gput:Nxx \g__zrefcheck_auxfile_labelseq_prop
                { \l_tmpa_tl } { \int_use:N \l_tmpa_int }
            }
        }
    \group_end:
    \ior_close:N \g_tmpa_ior
  }



%% The main user-facing command

% *[<options>]{<labels>}[<checks>]{<text>}
\NewDocumentCommand \zrefcheck { s O { } m O { } +m }
  { \zref@wrapper@babel \_zrefcheck:nnnnn {#3} {#1} {#2} {#4} {#5} }

\int_new:N \g__zrefcheck_id_int
\tl_new:N \l__zrefcheck_checkbeg_tl
\tl_new:N \l__zrefcheck_checkend_tl

% An intermediate internal function, which places "labels" as first argument,
% so that it can be protected by '\zref@wrapper@babel'.  This is more or less
% what the definition of '\zref' in 'zref-user.sty' does for this.
% {<labels>}*[<options>][<checks>]{<text>}
\cs_new_protected:Npn \_zrefcheck:nnnnn #1#2#3#4#5
  {
    \int_gincr:N \g__zrefcheck_id_int
    \mode_leave_vertical:
    \group_begin:
      % Names of the labels for this zrefcheck call
      \tl_set:Nx \l__zrefcheck_checkbeg_tl
        { \__zrefcheck_checkbeg_lblfmt:n { \g__zrefcheck_id_int } }
      \tl_set:Nx \l__zrefcheck_checkend_tl
        { \__zrefcheck_checkend_lblfmt:n { \g__zrefcheck_id_int } }
      % Set start label
      \zref@labelbylist { \l__zrefcheck_checkbeg_tl } { zrefcheck }
      % Typeset "<text>" (with hyperref!)
      \__zrefcheck_get_astl:nnn {#1} { anchor } { \l_tmpa_tl }
      \hyperlink { \l_tmpa_tl } {#5}
      % Set end label
      \zref@labelbylist { \l__zrefcheck_checkend_tl } { zrefcheck }
      % Now we do the checking

      % Check definition here, as appropriate, \__zrefcheck_get_astl:nnn
      % assumes the label is defined. Use:
      % \zref@ifrefundefined {#1} { } { }

      \__zrefcheck_do_check:nnv {#4} {#1} { l__zrefcheck_checkbeg_tl }
    \group_end:
  }



%% Auxiliary functions


% A convenience function to retrieve property values from labels.  Uses
% '\g__zrefcheck_auxfile_labelseq_prop' for "labelseq", and calls
% '\zref@extract' for everything else.
%
% We cannot use the return value of '\__zrefcheck_get_as(tl|int):nnn'
% directly, because we need to use the retrieved property values as arguments
% in the checks, however we use here a number of non-expandable operations.
% Hence, we receive a local tl/int variable as third argument and set that, so
% that it is available (and expandable) at the place of use.  For this reason,
% we do not group here, because we are passing a local variable around, but it
% is expected this function will be called within a group.
%
% I'm returning '\c_empty_tl' in case of failure to find the intended property
% value (explicitly in '\zref@extractdefault', but that is also what
% '\tl_clear:N' does).  This can also


% {<label>}{<prop>}{<tl var>}
\cs_new:Npn \__zrefcheck_get_astl:nnn #1#2#3
  {
    \tl_clear:N #3
    \tl_if_eq:nnTF {#2} { labelseq }
      {
        \prop_get:NnNF \g__zrefcheck_auxfile_labelseq_prop {#1} #3
          {
            \msg_warning:nnnn { zrefcheck }
              { property-not-in-label } {#1} {#2}
          }
      }
      {
        % There are three things we need to check to ensure the information we
        % are trying to retrieve here exists: the existence of "label", the
        % existence of "property", and whether the particular label being
        % queried actually contains the property.  If that's all in place, the
        % value is passed to the checks, and it's their responsibility to
        % verify the consistency of this value.
        %
        % The existence of the label is an user facing issue, and a
        % configurable one, so a warning for this should be placed in
        % '\_zrefcheck:nnnnn' (and done with '\zref@refused').  We do check
        % here though for definition with '\zref@ifrefundefined' and silently
        % do nothing if it is undefined, to reduce irrelevant warnings in a
        % fresh compilation round.  The other two are more "internal"
        % problems, either some problem with the checks, or with the
        % configuration of 'zref' for their consumption.

        \zref@ifrefundefined {#1}
          {}
          {
            \zref@ifpropundefined {#2}
              {
                \msg_warning:nnnn { zrefcheck }
                  { property-undefined } {#2}
              }
              {
                \zref@ifrefcontainsprop {#1} {#2}
                  {
                    \tl_set:Nx #3
                      { \zref@extractdefault {#1} {#2} { \c_empty_tl } }
                  }
                  {
                    \msg_warning:nnnn { zrefcheck }
                      { property-not-in-label } {#1} {#2}
                  }
              }
          }
      }
  }

\msg_new:nnn { zrefcheck } { property-undefined }
  { Property~'#1'~not~defined~on~input~line~\msg_line_number:. }

\msg_new:nnn { zrefcheck } { property-not-in-label }
  { Label~'#1'~has~no~property~'#2'~on~input~line~\msg_line_number:. }


\bool_new:N \l__zrefcheck_integer_bool

% {<label>}{<prop>}{<int var>}
\cs_new:Npn \__zrefcheck_get_asint:nnn #1#2#3
  {
    \__zrefcheck_get_astl:nnn {#1} {#2} { \l_tmpa_tl }
    % Make it an integer data type
    \is_integer:nTF { \l_tmpa_tl }
      { \int_set:Nn #3 { \int_eval:n { \l_tmpa_tl } } }
      {
        \bool_set_false:N \l__zrefcheck_integer_bool
        % Keep silent if ref is undefined to reduce irrelevant warnings in a
        % fresh compilation round.  Again, this is also not the point to check
        % for undefined references, that's a task for '\_zrefcheck:nnnnn'.
        \zref@ifrefundefined {#1}
          { }
          { \msg_warning:nnn { zrefcheck } { property-not-integer } {#2} }
      }
  }

% Thanks egreg: https://tex.stackexchange.com/a/244405
\prg_new_conditional:Npnn \is_integer:n #1 { p, T, F, TF }
  {
    \tl_if_empty:oTF {#1}
      { \prg_return_false: } % empty tl is also not an integer
      {
        \tl_if_blank:oTF { \__int_to_roman:w -0#1 }
          { \prg_return_true:  }
          { \prg_return_false: }
      }
  }

\msg_new:nnn { zrefcheck } { property-not-integer }
  { Property~'#1'~is~not~an~integer \\
    on~input~line~\msg_line_number:. }



%% Checks


% What is needed for a check to work?
%
% First, a conditional/predicate function defined with:
%
% \prg_new_protected_conditional:Npnn \__zrefcheck_check_<check>:nn #1#2 { T , F , TF }
%
% where "<check>", it the name of the check, the first argument is the "label"
% and the second the "reference".  The existence of the check is verified by
% the existence of the function with this name-scheme (and signatures).  Of
% course, this function must return either '\prg_return_true:' or
% '\prg_return_false:'. (It doesn't *need* to be 'protected' if the content of
% the test does not require it, but the package does not expect the
% '\__zrefcheck_check_<check>_p:nn' variant to exist).
%
% Note that the naming convention of the checks adopts the perspective of the
% "reference".  That is, the "before" check should return true if the "label"
% occurs before the "reference".
%
% The checks it does are expected to retrieve 'zref's label information with
% '\__zrefcheck_get_astl:nnn' or '\__zrefcheck_get_asint:nnn' (zref extract
% infrastructure is, naturally, also an alternative for the regular
% properties).  Also, technically speaking, the "reference" argument is also a
% label, actually a pair of them, as set by '\zrefcheck'.  For the "labels",
% any 'zref' property in 'zref's main list is available, the "references"
% store the properties in the 'zrefcheck' list.  Besides those, there is also
% the 'labelseq' (fake) property (for either "labels" or "references"), as
% provided by '\__zrefcheck_process_labelseq:', and stored in
% '\g__zrefcheck_auxfile_labelseq_prop'.
%
% Second, the required properties of labels and references must be duly
% registered for 'zref'.  This can be done with '\zref@newprop',
% '\zref@addprop' and friends, as usual.


% {<check>}{<label>}{<reference>}
\cs_new:Npn \__zrefcheck_do_check:nnn #1#2#3
  {
    \cs_if_exist:cTF { __zrefcheck_check_ #1 :nnF }
      {
        \use:c { __zrefcheck_check_ #1 :nnF } {#2} {#3}
          { \msg_warning:nnnn { zrefcheck } { check-failed } {#1} {#2} }
      }
      { \msg_warning:nnn { zrefcheck } { check-missing } {#1} }
  }

\cs_generate_variant:Nn \__zrefcheck_do_check:nnn { nnv }


\msg_new:nnn { zrefcheck } { check-failed }
  { Check~'#1'~for~label~'#2'~has~failed~on~input~line~\msg_line_number:. }

\msg_new:nnn { zrefcheck } { check-missing }
  { Check~'#1'~not~defined~on~input~line~\msg_line_number:. }


% {<list of checks>}{<label>}{<reference>}
\cs_new:Npn \__zrefcheck_do_check_list:nnn #1#2#3
  {

  }




% More readable scratch variables for the tests
\int_new:N \l__zrefcheck_lbl_int
\int_new:N \l__zrefcheck_ref_int
\int_new:N \l__zrefcheck_lbl_a_int
\int_new:N \l__zrefcheck_ref_a_int
\int_new:N \l__zrefcheck_lbl_b_int
\int_new:N \l__zrefcheck_ref_b_int


\prg_new_protected_conditional:Npnn \__zrefcheck_check_thispage:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \__zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \__zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_if:NTF \l__zrefcheck_integer_bool
        {
          \bool_if:nTF
            {
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int } &&
                % '0' is the default value of 'abspage' property, and this
                % value should not happen normally for this property, since
                % even the first page, after it gets shipped out, will store
                % '1'.  So, if we do find '0' here, better signal something is
                % wrong.
                ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
                ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
            }
            { \group_insert_after:N \prg_return_true:  }
            { \group_insert_after:N \prg_return_false: }
        }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }


\prg_new_protected_conditional:Npnn \__zrefcheck_check_nextpage:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \__zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \__zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_if:NTF \l__zrefcheck_integer_bool
        {
          \bool_if:nTF
            {
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int + 1 } &&
              % Ditto
              ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
              ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
            }
            { \group_insert_after:N \prg_return_true:  }
            { \group_insert_after:N \prg_return_false: }
        }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\prg_new_protected_conditional:Npnn \__zrefcheck_check_prevpage:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \__zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \__zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_if:NTF \l__zrefcheck_integer_bool
        {
          \bool_if:nTF
            {
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int - 1 } &&
              % Ditto
              ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
              ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
            }
            { \group_insert_after:N \prg_return_true:  }
            { \group_insert_after:N \prg_return_false: }
        }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }


\prg_new_protected_conditional:Npnn \__zrefcheck_check_pagesbefore:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \__zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \__zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_if:NTF \l__zrefcheck_integer_bool
        {
          \bool_if:nTF
            {
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } < { \l__zrefcheck_ref_int } &&
              % Ditto
              ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
              ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
            }
            { \group_insert_after:N \prg_return_true:  }
            { \group_insert_after:N \prg_return_false: }
        }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\cs_new_eq:NN \__zrefcheck_check_ppbefore:nnF \__zrefcheck_check_pagesbefore:nnF

\prg_new_protected_conditional:Npnn \__zrefcheck_check_pagesafter:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \__zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \__zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_if:NTF \l__zrefcheck_integer_bool
        {
          \bool_if:nTF
            {
              \int_compare_p:nNn
                { \l__zrefcheck_lbl_int } > { \l__zrefcheck_ref_int } &&
              % Ditto
              ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
              ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
            }
            { \group_insert_after:N \prg_return_true:  }
            { \group_insert_after:N \prg_return_false: }
        }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }

\cs_new_eq:NN \__zrefcheck_check_ppafter:nnF \__zrefcheck_check_pagesafter:nnF

\prg_new_protected_conditional:Npnn \__zrefcheck_check_facing:nn #1#2 { T , F , TF }
  {
    \group_begin:
      \bool_set_true:N \l__zrefcheck_integer_bool
      \__zrefcheck_get_asint:nnn {#1} { abspage } { \l__zrefcheck_lbl_int }
      \__zrefcheck_get_asint:nnn {#2} { abspage } { \l__zrefcheck_ref_int }
      \bool_if:NTF \l__zrefcheck_integer_bool
        {
          \bool_if:nTF
            {
              % There exists no "facing" page if the document is not twoside
              \legacy_if_p:n { @twoside } &&
              % Now we test "facing"
              (
                (
                  \int_if_odd_p:n { \l__zrefcheck_ref_int } &&
                  \int_compare_p:nNn
                    { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int - 1 }
                ) ||
                (
                  \int_if_even_p:n { \l__zrefcheck_ref_int } &&
                  \int_compare_p:nNn
                    { \l__zrefcheck_lbl_int } = { \l__zrefcheck_ref_int + 1 }
                )
              ) &&
              % Ditto
              ! \int_compare_p:nNn { \l__zrefcheck_lbl_int } = { 0 } &&
              ! \int_compare_p:nNn { \l__zrefcheck_ref_int } = { 0 }
            }
            { \group_insert_after:N \prg_return_true:  }
            { \group_insert_after:N \prg_return_false: }
        }
        { \group_insert_after:N \prg_return_false: }
    \group_end:
  }
